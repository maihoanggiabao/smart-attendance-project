arguments: src/align_dataset_mtcnn.py DataSet/FaceData/raw DataSet/FaceData/processed --image_size 160 --margin 32 --random_order --gpu_memory_fraction 0.25
--------------------
tensorflow version: 2.16.1
--------------------
git hash: b'69ff1e149c0d84a123d6516ddd82970e65392608'
--------------------
b'diff --git a/src/align_dataset_mtcnn.py b/src/align_dataset_mtcnn.py\nindex 27d460b..1a30633 100644\n--- a/src/align_dataset_mtcnn.py\n+++ b/src/align_dataset_mtcnn.py\n@@ -1,25 +1,3 @@\n-"""Performs face alignment and stores face thumbnails in the output directory."""\n-# MIT License\n-# \n-# Copyright (c) 2016 David Sandberg\n-# \n-# Permission is hereby granted, free of charge, to any person obtaining a copy\n-# of this software and associated documentation files (the "Software"), to deal\n-# in the Software without restriction, including without limitation the rights\n-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n-# copies of the Software, and to permit persons to whom the Software is\n-# furnished to do so, subject to the following conditions:\n-# \n-# The above copyright notice and this permission notice shall be included in all\n-# copies or substantial portions of the Software.\n-# \n-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n-# SOFTWARE.\n \n from __future__ import absolute_import\n from __future__ import division\n@@ -32,7 +10,7 @@ import argparse\n import tensorflow as tf\n import numpy as np\n import facenet\n-import align.detect_face\n+import Align.detect_face\n import random\n from time import sleep\n \n@@ -52,13 +30,13 @@ def main(args):\n         #gpu_options = tf.GPUOptions(per_process_gpu_memory_fraction=args.gpu_memory_fraction)\n         sess = tf.compat.v1.Session()#config=tf.ConfigProto())#gpu_options=gpu_options, log_device_placement=False))\n         with sess.as_default():\n-            pnet, rnet, onet = align.detect_face.create_mtcnn(sess, None)\n+            pnet, rnet, onet = Align.detect_face.create_mtcnn(sess, None)\n     \n     minsize = 20 # minimum size of face\n-    threshold = [ 0.6, 0.7, 0.7 ]  # three steps\'s threshold\n+    threshold = [ 0.5, 0.5, 0.5 ]  # three steps\'s threshold\n     factor = 0.709 # scale factor\n \n-    # Add a random key to the filename to allow alignment using multiple processes\n+    # Add a random key to the filename to allow Alignment using multiple processes\n     random_key = np.random.randint(0, high=99999)\n     bounding_boxes_filename = os.path.join(output_dir, \'bounding_boxes_%05d.txt\' % random_key)\n     \n@@ -94,7 +72,7 @@ def main(args):\n                             img = facenet.to_rgb(img)\n                         img = img[:,:,0:3]\n     \n-                        bounding_boxes, _ = align.detect_face.detect_face(img, minsize, pnet, rnet, onet, threshold, factor)\n+                        bounding_boxes, _ = Align.detect_face.detect_face(img, minsize, pnet, rnet, onet, threshold, factor)\n                         nrof_faces = bounding_boxes.shape[0]\n                         if nrof_faces>0:\n                             det = bounding_boxes[:,0:4]\n@@ -159,4 +137,4 @@ def parse_arguments(argv):\n     return parser.parse_args(argv)\n \n if __name__ == \'__main__\':\n-    main(parse_arguments(sys.argv[1:]))\n+    main(parse_arguments(sys.argv[1:])) #truyen vo tham so thu2 va thu 3 tuong ung voi source directory va destination directory\ndiff --git a/src/face_rec_cam.py b/src/face_rec_cam.py\nindex 1a425a5..876552b 100644\n--- a/src/face_rec_cam.py\n+++ b/src/face_rec_cam.py\n@@ -13,7 +13,7 @@ import os\n import sys\n import math\n import pickle\n-import align.detect_face\n+import Align.detect_face\n import numpy as np\n import cv2\n import collections\n@@ -52,12 +52,12 @@ def main():\n             facenet.load_model(FACENET_MODEL_PATH)\n \n             # Get input and output tensors\n-            images_placeholder = tf.get_default_graph().get_tensor_by_name("input:0")\n-            embeddings = tf.get_default_graph().get_tensor_by_name("embeddings:0")\n-            phase_train_placeholder = tf.get_default_graph().get_tensor_by_name("phase_train:0")\n+            images_placeholder = tf.compat.v1.get_default_graph().get_tensor_by_name("input:0")\n+            embeddings = tf.compat.v1.get_default_graph().get_tensor_by_name("embeddings:0")\n+            phase_train_placeholder = tf.compat.v1.get_default_graph().get_tensor_by_name("phase_train:0")\n             embedding_size = embeddings.get_shape()[1]\n \n-            pnet, rnet, onet = align.detect_face.create_mtcnn(sess, "src/align")\n+            pnet, rnet, onet = Align.detect_face.create_mtcnn(sess, "src/Align")\n \n             people_detected = set()\n             person_detected = collections.Counter()\n@@ -69,7 +69,7 @@ def main():\n                 frame = imutils.resize(frame, width=600)\n                 frame = cv2.flip(frame, 1)\n \n-                bounding_boxes, _ = align.detect_face.detect_face(frame, MINSIZE, pnet, rnet, onet, THRESHOLD, FACTOR)\n+                bounding_boxes, _ = Align.detect_face.detect_face(frame, MINSIZE, pnet, rnet, onet, THRESHOLD, FACTOR)\n \n                 faces_found = bounding_boxes.shape[0]\n                 try:\n@@ -119,16 +119,13 @@ def main():\n                                     person_detected[best_name] += 1\n                                 else:\n                                     name = "Unknown"\n-\n                 except:\n                     pass\n-\n                 cv2.imshow(\'Face Recognition\', frame)\n                 if cv2.waitKey(1) & 0xFF == ord(\'q\'):\n                     break\n-\n-            cap.release()\n+            \n+            cap.stop()\n             cv2.destroyAllWindows()\n \n-\n main()'